<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="fcModels" needs-time-series-data="true" minver="2016d">
<author email="yinung.yang@gmail.com">Yi-Nung Yang</author>
<version>1.21</version>
<date>2020-08-23</date>
<description>Forecasting models</description>
<tags>C22 C58</tags>
<label>fcModels</label>
<menu-attachment>MAINWIN/Model</menu-attachment>
<help>
This package provide in-sample and out-of-sample forecasting by several basic
forecasting models with automatic search for best parameters based on minimizing
MSE. After selecting the forecasting models, you may enter the number of last
observations for out-of-sample forecasts comparision. The forecasting models
included are:
(completed)
1. automatic lag selection for Moving Average: autoMA()
2. automatic parameter selection for Single Exponential Smoothing: autoSES()
3. automatic parameter selection for Double Exponential Smoothing: HoltDES()
4. automatic parameter selection for Triple Exponential Smoothing (Winters): wes
()
5. automatic parameter selection for Adaptive Response Rate Single Exponential
Smoothing: adres()
6. automatic selection of regressors including trend, period dummies, lags of
dependent variable with automatic omissions of insignificant regressors: autoOLS
()
7. generating Seasonal Index: genrSI()
8. Some measures for evaluating forecasting errors (RMSE, MAP, MAPE, and Theil's
U)

changelog:
==========================
2020/8/02
    ver. 1.21: minor changes on fcerr() to remove Theil's U as a default option.
2019/10/28
    ver. 1.2: fix RMSE according to changed behaviour of the built-in gretl
              function fcstats()
              fix deprecated isnull() with !exist()
2017/12/04
    ver. 0.98: Remove Chinese chacters from fcModels() to comply with
               requirement by gretl official.Chinese version can be installed
               via:
                install https://sites.google.com/site/gretlmenu/package/
fcModels.gfn
2017.11.06 syntax changes for gretl 2017c
           add autoOLS(), HotlDES(), wes(), adres()
2015.06.04 bug fix for gretl 1.10.1
</help>
<gretl-function name="autoMA" type="list">
 <params count="5">
  <param name="y_" type="series">
<description>Variable name</description>
  </param>
  <param name="lag" type="int" min="1" max="1000" default="10">
<description>Maximum lag:</description>
  </param>
  <param name="save_yf" type="bool" default="1">
<description>Use default name for forecast series?</description>
  </param>
  <param name="yfname" type="string" optional="true">
<description>_Save forecast...</description>
  </param>
  <param name="nOSample" type="int" min="0" max="5000" default="0">
<description>Number of Out-of-Sample reserved</description>
  </param>
 </params>
<code>set echo off
set messages off
# --- nOSample = 保留為樣本外預測樣本數
smpl ; -nOSample
series y=y_
sprintf tmp &quot;%s&quot;,argname(y_)	# name for y
series @tmp=y_
matrix mx={}
matrix stats={}
# the naive model
# --- 先用 OLS 跑之後, 確認是否要做 &quot;真的&quot; 預測, 即檢查最後幾筆是否無資料
ols y_ const -q
genr sdum=$sample
series f=movavg(y_(-1),1)
#print f --byobs
smpl sdum --dummy
#print y_ f --byobs
smpl +1 ;
matrix mm=fcstats(y_,f)
MSE=mm[2]
MAE=mm[3]
MAPE=mm[5]
TheilU=mm[6]
/*
print &quot;--- The Naive model: -------------------------------------------&quot;
printf &quot;MSE = %.4f\n&quot;,mm[2]
printf &quot;MAE = %.4f\n&quot;,mm[3]
printf &quot;MAPE = %.4f\n&quot;,mm[5]
printf &quot;Theil's U = %.4f\n&quot;,mm[6]
*/
loop i=1..lag -q
  smpl full
  smpl sdum --dummy
  series f=movavg(y_(-1),i)
  smpl +(i+1) ;
  #print y_ f --byobs
  matrix m=fcstats(y_,f)
  matrix mx = mx | m'
endloop
mmse=mx[,2]
# best lag = k
k=iminc(mmse)
if !exists(yfname)
  smpl full
  scalar predh = $t2-lastobs(y)
  if predh&gt;0
    sprintf yf &quot;%s_ma%d_out&quot;,argname(y_),k	# default name for yf
  else
    sprintf yf &quot;%s_ma%d&quot;,argname(y_),k	# default name for yf
  endif
else
  sprintf yf &quot;%s&quot;,yfname	# user defined name for yf
endif
smpl full
#  smpl +lag ;
printf &quot;====================================================\n&quot;
set messages on
smpl +lag -nOSample
set messages off
printf &quot;Forecasts by Simple Moving Average\n&quot;
printf &quot;----------------------------------------------------\n&quot;
printf &quot;   Searching lags from %d to %d\n&quot;, 1,lag
printf &quot;   The parameter based on min. MSE is: \n&quot;
printf &quot;       Lag: %d\n&quot;,k
printf &quot;Original series: %s\n&quot;, argname(y_)
printf &quot;Forecast series: %s\n&quot;, &quot;@yf&quot;
printf &quot;----------------------------------------------------\n&quot;
smpl full
# ---- 樣本外預測: 在 smpl full 之後, 看最後有幾筆 missing variable ---
# Number of predictions, equal to the number of missing obs. at the end of the variable
scalar lobs=lastobs(y)-firstobs(y)+1 # Current sample size
if $t2 &gt;=lastobs(y_)
  scalar predh = $t2-lastobs(y_)+nOSample
  EOB=lastobs(y_)-nOSample # ---&gt; predh
  EOS=lastobs(y_)
else
  scalar predh = nOSample
  EOB=$t2- nOSample # ---&gt; predh
  EOS=$t2
endif
########  scalar predh = $t2-lastobs(y_)+nOSample
#printf &quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;t2=%d; lobs=%d; predh=%d; \n&quot;,$t2,lobs,predh
#BOB=firstobs(@tmp)+k
#EOB=lastobs(@tmp)-predh
BOB=firstobs(y_)+k
################  EOB=lastobs(y_)-nOSample # ---&gt; predh
# --- Begin/End of Out-of-Sample
#BOS=lastobs(@tmp)-predh+1
#EOS=lastobs(@tmp)
BOS=lastobs(y_)-predh+1
################  EOS=lastobs(y_)
if predh&gt;0
  series tmp0=y
  #print y_ y tmp0 --byobs
  smpl ; -predh
  loop i=1..predh --quiet
    #scalar ji=lobs+i+1
    scalar ji=EOB+i
    #set echo on
    #set messages on
    smpl ; +1
    series tmp1=movavg(tmp0(-1),k)
    genr tmp0[ji] = tmp1[ji]
    #printf &quot;ji=%d\n&quot;,ji
    #print y_ y tmp1 tmp0 --byobs
  endloop
  series @yf=tmp1
  smpl full
  smpl ; -predh
  sprintf sInfo &quot;movavg(%s(-1),%d); The last-%d observations are out-of-sample forecasts &quot;,argname(y_),k,predh
  series @yf=movavg(y(-1),k)
  #print y_ y tmp0 tmp1 --byobs
  # --- 顯示樣本內、外的 RMSE
  smpl full
  #print y_ @yf time tmp1 --byobs
  BOB=firstobs(@tmp)+k
  #EOB=lastobs(@tmp)-predh
  #printf &quot;************* BOB=%d; EOB=%d; \n&quot;,BOB,EOB
  printf &quot;   ++++++++++++++++++++++++++++++++++++++++++\n&quot;
  printf &quot;          In-sample forecasting Errors\n&quot;
  printf &quot;   ++++++++++++++++++++++++++++++++++++++++++\n&quot;
  fcerr(y_,@yf,BOB,EOB,1)
  #fcerr(@tmp,@yf,lastobs(@tmp)-predh+1,lastobs(@tmp),1,1)
  if nOSample&gt;0
    printf &quot;   ++++++++++++++++++++++++++++++++++++++++++++++\n&quot;
    printf &quot;        Out-of-sample forecasting Errors\n&quot;
    printf &quot;   ++++++++++++++++++++++++++++++++++++++++++++++\n&quot;
    fcerr(y_,@yf,EOS-nOSample+1,EOS,1) # ---&gt;    fcerr(y_,@yf,BOS,EOS,1)
  endif
  printf &quot;====================================================\n\n&quot;
else
  sprintf sInfo &quot;movavg(%s(-1),%d)&quot;,argname(y_),k
  series @yf=movavg(y(-1),k)
  # --- 顯示樣本外的 RMSE
  smpl full
  #BOB=firstobs(@tmp)+k
  #EOB=lastobs(@tmp)-predh
  #printf &quot;===BOB=%d; EOB=%d\n&quot;,BOB,EOB
  #printf &quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BOB=%d; EOB=%d; \n&quot;,BOB,EOB
  printf &quot;   ++++++++++++++++++++++++++++++++++++++++++\n&quot;
  printf &quot;          In-sample forecasting Errors\n&quot;
  printf &quot;   ++++++++++++++++++++++++++++++++++++++++++\n&quot;
  fcerr(y_,@yf,BOB,EOB,1)
  printf &quot;====================================================\n\n&quot;
endif
setinfo @yf -d &quot;@sInfo&quot;
list retlist= @yf
return retlist
</code>
</gretl-function>
<gretl-function name="autoSES" type="list">
 <params count="4">
  <param name="y_" type="series">
<description>Variable name</description>
  </param>
  <param name="save_yf" type="bool" default="1">
<description>Use default name for forecast series?</description>
  </param>
  <param name="yfname" type="string" optional="true">
<description>Name of forecasts (user provided)</description>
  </param>
  <param name="nOSample" type="int" min="0" max="5000" default="0">
<description>Number of Out-of-Sample reserved</description>
  </param>
 </params>
<code>#================================================================
#   find best parameters for Expo Smoothing for gretl by Yi-Nung Yang
#   Chung Yuan Christian University, Taiwan
#   http://yaya.it.cycu.edu.tw/gretl
#   version: 2014.02.17 改版; 2014.04.16 改版; 2017.11.06 改版
#   Note: 與 autoMA 相同, 只要新增空白樣本後, 即可自動預測
#================================================================
set echo off
set messages off
# --- nOSample = 保留為樣本外預測樣本數
smpl ; -nOSample
series y=y_
sprintf tmp &quot;%s&quot;,argname(y_)	# name for y
series @tmp=y_
matrix mx={}
matrix stats={}
# the naive model
# --- 先用 OLS 跑之後, 確認是否要做 &quot;真的&quot; 預測, 即檢查最後幾筆是否無資料
ols y_ const -q
genr sdum=$sample
series f=movavg(y_(-1),1)
smpl sdum --dummy
smpl +1 ;
matrix mm=fcstats(y_,f)
MSE=mm[2]
MAE=mm[3]
MAPE=mm[5]
TheilU=mm[6]
scalar maxM = 99
scalar minM = 1
matrix mSSE = zeros(maxM-minM+1,2)
# sum of square errors
#loop for j= minM..maxM -q
j=minM
loop for (i=.01; i&lt;=.999; i+=.01) -q
  series mv=movavg(y(-1),i)
  series f = mv
  SSE = (mean((y-f)^2)^0.5)  #RMSE
  mSSE[j-minM+1,1]=i
  mSSE[j-minM+1,2]=SSE
  j+=1
endloop
#print mSSE
# return a vector with minimal value in columns
matrix Cmin=minc(mSSE)
# return an index vector for above minimal values in columns
matrix iCmin=iminc(mSSE)
matrix stat= mSSE[iCmin[2],1] ~ Cmin[2]
#   print stat
if !exists(yfname)
  smpl full
  scalar predh = $t2-lastobs(y)
  if predh&gt;0
    sprintf yf &quot;%s_ses_out&quot;,argname(y_)	# default name for yf
  else
    sprintf yf &quot;%s_ses&quot;,argname(y_)	# default name for yf
  endif
else
  sprintf yf &quot;%s&quot;,yfname	# user defined name for yf
endif
smpl full
#  smpl +lag ;
printf &quot;====================================================\n&quot;
set messages on
smpl +1 -nOSample
set messages off
printf &quot;Forecasts by Single Exponential Smoothing\n&quot;
printf &quot;----------------------------------------------------\n&quot;
printf &quot;   The parameter based on min. MSE is: \n&quot;
printf &quot;Alpha: %.3f\n&quot;,stat[1]
printf &quot;Original series: %s\n&quot;, argname(y_)
printf &quot;Forecast series: %s\n&quot;, &quot;@yf&quot;
printf &quot;----------------------------------------------------\n&quot;
smpl full
# ---- 樣本外預測: 在 smpl full 之後, 看最後有幾筆 missing variable ---
# Number of predictions, equal to the number of missing obs. at the end of the variable
scalar lobs=lastobs(y)-firstobs(y)+1 # Current sample size
if $t2 &gt;=lastobs(y_)
  scalar predh = $t2-lastobs(y_)+nOSample
  EOB=lastobs(y_)-nOSample # ---&gt; predh
  EOS=lastobs(y_)
else
  scalar predh = nOSample
  EOB=$t2- nOSample # ---&gt; predh
  EOS=$t2
endif
#printf &quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;t2=%d;lastobs(y_)=%d; lobs=%d; predh=%d; \n&quot;,$t2,lastobs(y_),lobs,predh
BOB=firstobs(y_)+1
#############  EOB=lastobs(y_)-nOSample # ---&gt; predh
# printf &quot;&gt;&gt;&gt;&gt;----&gt;&gt;&gt;&gt;&gt;&gt;&gt; BOB=%d; EOB=%d; predh=%d; \n&quot;,BOB,EOB,predh
# --- Begin/End of Out-of-Sample
#BOS=lastobs(@tmp)-predh+1
#EOS=lastobs(@tmp)
BOS=lastobs(y_)-predh+1
###############  EOS=lastobs(y_)
#printf &quot;&gt;&gt;&gt;&gt;***sm&gt;&gt;&gt;&gt;&gt;&gt;&gt; EOS=%d; BOS=%d; predh=%d; \n&quot;,EOS,BOS,predh
# ---- 以下進行樣本內預測 ----------------------
if predh&gt;0
  series tmp0=y
  #print y_ y tmp0 --byobs
  smpl full
  smpl ; -predh
  loop i=1..predh --quiet
    #scalar ji=lobs+i+1
    scalar ji=EOB+i
    #set echo on
    #set messages on
    smpl ; +1
    # ----&gt; series tmp1=movavg(y(-1),mSSE[iCmin[2],1])
    series tmp1=movavg(tmp0(-1),mSSE[iCmin[2],1])
    genr tmp0[ji] = tmp1[ji]
    #printf &quot;ji=%d\n&quot;,ji
  endloop
  #print y_ y tmp0 tmp1 --byobs
  series @yf=tmp1
  smpl full
  smpl ; -predh
  sprintf sInfo &quot;movavg(%s(-1),%.3f); The last-%d observations are out-of-sample forecasts &quot;,argname(y_),mSSE[iCmin[2],1],predh
  series @yf=movavg(y(-1),mSSE[iCmin[2],1])
  #smpl full
  #print y_ y tmp0 tmp1 --byobs
  # --- 顯示樣本內、外的 RMSE
  smpl full
  #print y_ @yf time tmp1 --byobs
  BOB=firstobs(@tmp)+1
  #EOB=lastobs(@tmp)-predh
  #printf &quot;************* BOB=%d; EOB=%d; \n&quot;,BOB,EOB
  printf &quot;   ++++++++++++++++++++++++++++++++++++++++++\n&quot;
  printf &quot;          In-sample forecasting Errors\n&quot;
  printf &quot;   ++++++++++++++++++++++++++++++++++++++++++\n&quot;
  fcerr(y_,@yf,BOB,EOB,1)
  #fcerr(@tmp,@yf,lastobs(@tmp)-predh+1,lastobs(@tmp),1,1)
  if nOSample&gt;0
    printf &quot;   ++++++++++++++++++++++++++++++++++++++++++++++\n&quot;
    printf &quot;        Out-of-sample forecasting Errors\n&quot;
    printf &quot;   ++++++++++++++++++++++++++++++++++++++++++++++\n&quot;
    #printf &quot;&gt;&gt;&gt;&gt;***sm&gt;&gt;&gt;&gt;&gt;&gt;&gt; EOS=%d; nOSample=%d; EOS=%d; \n&quot;,EOS,nOSample,EOS
    #print y_ @yf --byobs
    fcerr(y_,@yf,EOS-nOSample+1,EOS,1)
    printf &quot;====================================================\n\n&quot;
  endif
else
  sprintf sInfo &quot;movavg(%s(-1),%.3f)&quot;,argname(y_),mSSE[iCmin[2],1]
  series @yf=movavg(y(-1),mSSE[iCmin[2],1])
  # --- 顯示樣本外的 RMSE
  smpl full
  #BOB=firstobs(@tmp)+k
  #EOB=lastobs(@tmp)-predh
  #printf &quot;===BOB=%d; EOB=%d\n&quot;,BOB,EOB
  #printf &quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt; BOB=%d; EOB=%d; \n&quot;,BOB,EOB
  printf &quot;   ++++++++++++++++++++++++++++++++++++++++++\n&quot;
  printf &quot;          In-sample forecasting Errors\n&quot;
  printf &quot;   ++++++++++++++++++++++++++++++++++++++++++\n&quot;
  fcerr(y_,@yf,BOB,EOB,1)
  printf &quot;====================================================\n\n&quot;
endif
setinfo @yf -d &quot;@sInfo&quot;
list retlist= @yf
return retlist
</code>
</gretl-function>
<gretl-function name="HoltDES" type="list">
 <params count="7">
  <param name="y_" type="series">
<description>Variable name</description>
  </param>
  <param name="save_yf" type="bool" default="1">
<description>Use default name for forecast series, e,g., *_ef?</description>
  </param>
  <param name="yfname" type="string" optional="true">
<description>Name of forecasts</description>
  </param>
  <param name="auto" type="int" min="1" max="2" default="1">
<description>Para. Options</description>
<labels count="2">
"auto selection" "user provided below:" </labels>
  </param>
  <param name="myalpha" type="scalar" min="0" max="1" default="0.3">
<description>alpha  (Level):</description>
  </param>
  <param name="mygamma" type="scalar" min="0" max="1" default="0.1">
<description>gamma  (Trend):</description>
  </param>
  <param name="nOSample" type="int" min="0" max="5000" default="0">
<description>Number of Out-of-Sample reserved</description>
  </param>
 </params>
<code>set echo off
set messages off
# --- nOSample = 保留為樣本外預測樣本數
smpl ; -nOSample
series y=y_
sprintf tmp &quot;%s&quot;,argname(y_)	# name for y
series @tmp=y_
matrix mx={}
matrix stats={}
# the naive model
# --- 先用 OLS 跑之後, 確認是否要做 &quot;真的&quot; 預測, 即檢查最後幾筆是否無資料
ols y_ const -q
genr sdum=$sample
series f=movavg(y_(-1),1)
#print f --byobs
smpl sdum --dummy
smpl +1 ;
matrix mm=fcstats(y_,f)
MSE=mm[2]
MAE=mm[3]
MAPE=mm[5]
TheilU=mm[6]
#--- searching for optimal beta ~(0,1)
scalar maxM = 99
scalar minM = 1
#    matrix mSSE = zeros(maxM-minM+1,2)
jj=minM
m=1
minSSE=MSE^0.5
#printf &quot;=============&gt;&gt;&gt;MSE=%.4f; minSSE=%.4f\n&quot;,MSE,minSSE
minAlpha=0
minGamma=0
smpl full
smpl sdum --dummy
#print y_ y f --byobs
series x=y
ff=HW2(x)
#printf &quot;*******************\n&quot;
if !exists(yfname)
  smpl full
  scalar predh = $t2-lastobs(y)
  if predh&gt;0
    sprintf yf &quot;%s_des_out&quot;,argname(y_)	# default name for yf
  else
    sprintf yf &quot;%s_des&quot;,argname(y_)	# default name for yf
  endif
else
  sprintf yf &quot;%s&quot;,yfname	# user defined name for yf
endif
smpl full
# ---- 樣本外預測: 在 smpl full 之後, 看最後有幾筆 missing variable ---
# Number of predictions, equal to the number of missing obs. at the end of the variable
scalar lobs=lastobs(y)-firstobs(y)+1 # Current sample size
if $t2 &gt;=lastobs(y_)
  scalar predh = $t2-lastobs(y_)+nOSample
  EOB=lastobs(y_)-nOSample # ---&gt; predh
  EOS=lastobs(y_)
else
  scalar predh = nOSample
  EOB=$t2- nOSample # ---&gt; predh
  EOS=$t2
endif
BOS=lastobs(y_)-predh+1
printf &quot;&gt;&gt;&gt;&gt;***sm&gt;&gt;&gt;&gt;&gt;&gt;&gt; EOS=%d; EOB=%d; predh=%d; \n&quot;,EOS,EOB,predh
smpl firstobs(y_) -predh
if auto==1
  loop for (alpha=.01; alpha&lt;=.999; alpha+=.01) -q
    # ---- level parameter ------------
    loop for (gamma=.01; gamma&lt;=.999; gamma+=.01) -q
      smpl firstobs(y_) ;
      list tmpL=HW2(x,alpha,gamma) # --- will return a list containing y_H, y_W (if $pd&lt;&gt;1)
      series f=x_H
      smpl firstobs(y_)+1 ;
      #print y x_H --byobs
      matrix mm1=fcstats(y,f)
      SSE=mm1[2]^0.5
      #printf &quot;****=============SSE=%.4f; minSSE=%.4f\n&quot;,SSE,minSSE
      if alpha==0.01
        minSSE=SSE
        #printf &quot;=place 1============\n&quot;
        minAlpha=alpha
        minGamma=gamma
      else
        if SSE&lt;minSSE
          #printf &quot;=place 2============\n&quot;
          minSSE=SSE
          minAlpha=alpha
          minGamma=gamma
        endif
      endif
      jj+=1
    endloop
  endloop
else
  minAlpha=myalpha
  minGamma=mygamma
endif
printf &quot;minAlpha=%.3f; minGamma=%.3f\n&quot;,minAlpha,minGamma
#printf &quot;=OOOOK============\n&quot;
printf &quot;=====================================================\n&quot;
set messages on
smpl
set messages off
printf &quot;Forecasts by Holt's DES (Double Exponential Smoothing)\n&quot;
printf &quot;-----------------------------------------------------\n&quot;
printf &quot;The parameter is based on min. MSE \n&quot;
printf &quot;   alpha: %.3f\n&quot;,minAlpha    #---舊---&gt; stat[1]
printf &quot;   gamma: %.3f\n&quot;,minGamma    #---舊---&gt; stat[1]
printf &quot;Original series: %s\n&quot;, argname(y_)
printf &quot;Forecast series: %s\n&quot;, &quot;@yf&quot;
printf &quot;-----------------------------------------------------\n&quot;
sprintf sInfo &quot;HoltDES(%s,level:alpha=%.3f,trend:gamma=%.3f)&quot;,argname(y_),minAlpha, minGamma
smpl full
#    smpl 1 -predh
smpl firstobs(y_) ;
list tmpL=HW2(x,minAlpha,minGamma)
series @yf=x_H
setinfo @yf -d &quot;@sInfo&quot;
#print mSSE
sprintf tmp &quot;%s&quot;,argname(y_)	# name for y
series @tmp=y
#print y_ @tmp x_H time --byobs
# --- 測試用---&gt;&gt; print y @yf F T --byobs
/*
BOB=$t1+1   # ---Holt 法前1期是用 naive forecasting, 所以去掉
EOB=$t2
fcerr(@tmp,@yf,BOB,EOB,1,1)
*/
BOB=firstobs(@tmp)+1
printf &quot;   ++++++++++++++++++++++++++++++++++++++++++\n&quot;
printf &quot;          In-sample forecasting Errors\n&quot;
printf &quot;   ++++++++++++++++++++++++++++++++++++++++++\n&quot;
fcerr(y_,@yf,BOB,EOB,1)
if nOSample&gt;0
  printf &quot;   ++++++++++++++++++++++++++++++++++++++++++++++\n&quot;
  printf &quot;        Out-of-sample forecasting Errors\n&quot;
  printf &quot;   ++++++++++++++++++++++++++++++++++++++++++++++\n&quot;
  #printf &quot;&gt;&gt;&gt;&gt;***sm&gt;&gt;&gt;&gt;&gt;&gt;&gt; EOS=%d; nOSample=%d; EOS=%d; \n&quot;,EOS,nOSample,EOS
  #print y_ @yf --byobs
  fcerr(y_,@yf,EOS-nOSample+1,EOS,1)
endif
printf &quot;=====================================================\n\n&quot;
list retlist= @yf
return retlist
</code>
</gretl-function>
<gretl-function name="wes" type="list">
 <params count="9">
  <param name="y" type="series">
<description>Variable name</description>
  </param>
  <param name="save_yf" type="bool" default="1">
<description>Use default name for forecast series, e.g., *_ef?</description>
  </param>
  <param name="yfname" type="string" optional="true">
<description>Name of forecasts</description>
  </param>
  <param name="auto" type="int" min="1" max="2" default="1">
<description>Para. Options</description>
<labels count="2">
"auto selection" "user provided below:" </labels>
  </param>
  <param name="myalpha" type="scalar" min="0" max="1" default="0.41">
<description>alpha  (Level):</description>
  </param>
  <param name="mygamma" type="scalar" min="0" max="1" default="0.03">
<description>gamma  (Trend):</description>
  </param>
  <param name="mybeta" type="scalar" min="0" max="1" default="0.37">
<description>beta  (Seasonality):</description>
  </param>
  <param name="nYr" type="int" min="2" default="4">
<description>Number of Years for initial estimates</description>
  </param>
  <param name="showForecast" type="bool" default="0">
<description>show forecasted results</description>
  </param>
 </params>
<code>/*
scalar alpha=0.77
scalar gamma=0.39
scalar beta=0.37
*/
series F=NA
series T=NA
series S=NA
series f=NA
# --- generate first 1 forecasts
ols y 0 time --quiet
series yh=$yhat
genr F[firstobs(y)]=yh[firstobs(y)]
genr F[firstobs(y)+1]=yh[firstobs(y)+1]
genr T[firstobs(y)]=yh[firstobs(y)+1]-yh[firstobs(y)]
genr T[firstobs(y)+1]=yh[firstobs(y)+2]-yh[firstobs(y)+1]
# --- get initial Seasonality indicex from function genrSI(y,4) for 4-year data
matrix mSI=genrSI(y,nYr)
loop i=1..$pd -q
  genr S[i]=mSI[i]
endloop
scalar BOB=firstobs(y)+1
scalar EOB=lastobs(y)-firstobs(y)+1 # Current sample size
#--- searching for optimal beta ~(0,1)
scalar maxM = 99
scalar minM = 1
matrix mSSE = zeros(maxM-minM+1,2)
jj=minM
m=1
minSSE=9999999999999999999
minAlpha=0
minGamma=0
minBeta=0
if auto==1
  loop for (g=.01; g&lt;=.99; g+=.03) -q
    scalar beta=g
    loop for (k=.01; k&lt;=.99; k+=.05) -q
      scalar gamma=k
      jj=1
      loop for (i=.01; i&lt;=.99; i+=.05) -q
        scalar alpha=i
        loop j=BOB..EOB --quiet
          if j&lt;=$pd
            scalar S_p=mSI[j]
          else
            scalar S_p=S[j-$pd]
          endif
          genr F[j]=alpha*y[j]/S_p+(1-alpha)*(F[j-1]+T[j-1])
          genr T[j]=gamma*(F[j]-F[j-1])+ (1-gamma)*T[j-1]
          genr S[j]=beta*y[j]/F[j]+(1-beta)*S_p
          # ---  f == Winter's prediction
          if j+m&lt;=$pd
            scalar S_p=mSI[j+m]
          else
            scalar S_p=S[j+m-$pd]
          endif
          # ----&gt;&gt;&gt;genr f[j]=(F[j] + m*T[j])*S[j+m-$pd]
          if j&lt;=EOB-1
            genr f[j+1]=(F[j] + m*T[j])*S[j+m-$pd]
          endif
          #printf &quot;j=%d,S=%.3f,F=%.3f,T=%.3f\n&quot;,j,S[j],F[j],T[j]
        endloop
        SSE = (mean((y-f)^2)^0.5)  #RMSE
        mSSE[jj-minM+1,1]=i
        mSSE[jj-minM+1,2]=SSE
        if g==0.01
          #printf &quot;g=%.3f,SSE=%.3f, minSSE=%.3f\n&quot;,g,SSE,minSSE
          minSSE=SSE
          minAlpha=alpha
          minGamma=gamma
          minBeta=beta
        else
          # printf &quot;SSE=%.f, minSSE=%.f\n&quot;,SSE,minSSE
          if SSE&lt;=minSSE
            minSSE=SSE
            minAlpha=alpha
            minGamma=gamma
            minBeta=beta
          endif
        endif
        jj+=1
      endloop
    endloop
  endloop
endif
#print mSSE
# return a vector with minimal value in columns
matrix Cmin=minc(mSSE)
# return an index vector for above minimal values in columns
matrix iCmin=iminc(mSSE)
matrix stat= mSSE[iCmin[2],1] ~ Cmin[2]
#   print stat
if !exists(yfname)
  sprintf yf &quot;%s_TES&quot;,argname(y)	# default name for yf
else
  sprintf yf &quot;%s&quot;,yfname	# user defined name for yf
endif
printf &quot;=====================================================\n&quot;
set messages on
smpl
set messages off
if auto==2   # --- 自訂非自動找尋 beta 參數
  scalar alpha=myalpha
  scalar gamma=mygamma
  scalar beta=mybeta
else
  scalar alpha=minAlpha   # ---old---&gt;&gt; stat[1]
  scalar gamma=minGamma
  scalar beta=minBeta
endif
printf &quot;Forecasts by Winter's TES (Triple Exponential Smoothing)\n&quot;
printf &quot;-----------------------------------------------------\n&quot;
printf &quot;The parameter is based on min. MSE \n&quot;
printf &quot;   Level alpha: %.3f\n&quot;,alpha    #---舊---&gt; stat[1]
printf &quot;   Trend gamma: %.3f\n&quot;,gamma
printf &quot;   Seasonality beta: %.3f\n&quot;,beta
printf &quot;Original series: %s\n&quot;, argname(y)
printf &quot;Forecast series: %s\n&quot;, &quot;@yf&quot;
printf &quot;-----------------------------------------------------\n&quot;
sprintf sInfo &quot;Winters(%s,level:alpha=%.3f,trend:gamma=%.3f,seasonality:beta=%.3f)&quot;,argname(y),alpha, gamma,beta   # ---&gt;&gt; mSSE[iCmin[2],1]
#  series @yf=movavg(y(-1),mSSE[iCmin[2],1])
# --- 產生最佳預測值
#scalar alpha=stat[1]
BOB=firstobs(y)   # --- 從第2筆就計算預測值 f
loop j=BOB..EOB --quiet
  if j&lt;=$pd
    scalar S_p=mSI[j]
  else
    scalar S_p=S[j-$pd]
  endif
  genr F[j]=alpha*y[j]/S_p+(1-alpha)*(F[j-1]+T[j-1])
  genr T[j]=gamma*(F[j]-F[j-1])+ (1-gamma)*T[j-1]
  genr S[j]=beta*y[j]/F[j]+(1-beta)*S_p
  # ---  f == Winter's prediction
  if j+m&lt;=$pd
    scalar S_p=mSI[j+m]
  else
    scalar S_p=S[j+m-$pd]
  endif
  # ----&gt;&gt;&gt;genr f[j]=(F[j] + m*T[j])*S[j+m-$pd]
  if j&lt;=EOB-1
    genr f[j+1]=(F[j] + m*T[j])*S_p
  endif
endloop
series @yf=f
setinfo @yf -d &quot;@sInfo&quot;
#print mSSE
sprintf tmp &quot;%s&quot;,argname(y)	# name for y
series @tmp=y
# --- 測試用---&gt;&gt; print y @yf F T --byobs
BOB=$t1+1   # ---Holt 法前1期是用 naive forecasting, 所以去掉
EOB=$t2
fcerr(@tmp,@yf,BOB,EOB,1,1)
printf &quot;=====================================================\n&quot;
if showForecast
  print F T S f --byobs
endif
list retlist= @yf
return retlist
</code>
</gretl-function>
<gretl-function name="adres" type="list">
 <params count="6">
  <param name="y" type="series">
<description>Variable name</description>
  </param>
  <param name="save_yf" type="bool" default="1">
<description>Use default name for forecast series, e.g., *_adres?</description>
  </param>
  <param name="yfname" type="string" optional="true">
<description>Name of forecasts (user provided)</description>
  </param>
  <param name="auto" type="int" min="1" max="2" default="1">
<description>Para. Options</description>
<labels count="2">
"auto selection" "user provided below" </labels>
  </param>
  <param name="mybeta" type="scalar" min="0" max="1" default="0.143">
<description>beta  (Level):</description>
  </param>
  <param name="nOSample" type="int" min="0" max="5000" default="0">
<description>Number of Out-of-Sample reserved</description>
  </param>
 </params>
<code>series Serr=0
series Aerr=0
series Err=NA
series alpha=NA
series f=NA
set echo off
set messages off
# --- nOSample = 保留為樣本外預測樣本數
scalar predh = $t2-lastobs(y)
smpl ; -nOSample
# --- 先用 OLS 跑之後, 確認是否要做 &quot;真的&quot; 預測, 即檢查最後幾筆是否無資料
ols y const -q
genr sdum=$sample
series f=movavg(y(-1),1)
#    print f --byobs
set messages on  #YYYYYYYYYYYYY
smpl sdum --dummy
set messages off #YYYYYYYYYYYYY
# ------------------------------scalar beta=0.2
# --- generate first 2 forecasts
genr f[firstobs(y)]=y[firstobs(y)]
genr f[firstobs(y)+1]=y[firstobs(y)+1]
/*
scalar BOB=firstobs(y)+1
scalar EOB=lastobs(y)-firstobs(y)+1 # Current sample size
*/
scalar BOB=firstobs(y)
scalar EOB=lastobs(y)-nOSample
printf &quot;$t1=%d, $t2=%d ^^^^^^^^^^^^^^^^^^^^^\n&quot;, $t1,$t2
printf &quot;BOB=%d, EOB=%d, predh=%d ^^^^^^^^^^^^^^^^^^^^^\n&quot;, BOB,EOB,predh
#--- searching for optimal beta ~(0,1)
scalar maxM = 99
scalar minM = 1
matrix mSSE = zeros(maxM-minM+1,2)
jj=minM
loop for (i=.01; i&lt;=.999; i+=.01) -q
  scalar beta=i
  loop j=BOB+1..EOB --quiet
    genr Err[j]=y[j]-f[j]
    genr Serr[j]=beta*Err[j] + (1-beta)*Serr[j-1]
    genr Aerr[j]=beta*abs(Err[j])+(1-beta)*Aerr[j-1]
    if Aerr[j]==0  #--- 有些資料剛好前幾筆相同, 會有 divided by zero 的狀況, 用很小的非零數隨來排除
      Aerr[j]=0.001*randgen1(z, 0, 1)
    endif
    genr alpha[j] = abs(Serr[j]/Aerr[j])
    if j&lt;=EOB-1
      genr f[j+1]=alpha[j]*y[j] + (1-alpha[j])*f[j]
    endif
  endloop
  SSE = (mean((y-f)^2)^0.5)  #RMSE
  mSSE[jj-minM+1,1]=i
  mSSE[jj-minM+1,2]=SSE
  jj+=1
endloop
print &quot;1:============&quot;
# print y f Err Serr Aerr --byobs
#print mSSE
# return a vector with minimal value in columns
matrix Cmin=minc(mSSE)
# return an index vector for above minimal values in columns
matrix iCmin=iminc(mSSE)
matrix stat= mSSE[iCmin[2],1] ~ Cmin[2]
#   print stat
if !exists(yfname)
  smpl full
  scalar predh = $t2-lastobs(y)
  if predh&gt;0
    sprintf yf &quot;%s_adres_out&quot;,argname(y)	# default name for yf
  else
    sprintf yf &quot;%s_adres&quot;,argname(y)	# default name for yf
  endif
else
  sprintf yf &quot;%s&quot;,yfname	# user defined name for yf
endif
if auto==2   # --- 自訂非自動找尋 beta 參數
  scalar beta=mybeta
else
  scalar beta=stat[1]
endif
smpl full
printf &quot;=====================================================\n&quot;
set messages on
smpl +1 -nOSample
set messages off
printf &quot;Forecasts by ADRES models\n(Adaptive-Response-Rate Exponential Smoothing)\n&quot;
printf &quot;-----------------------------------------------------\n&quot;
printf &quot;f(t+1) = alpha(t)*y(t)+(1-alpha(t))*f(t)\n\n&quot;
printf &quot;  alpha(t)=abs(S(t)/A(t))\t\t (time-varying alpha)\n&quot;
printf &quot;  S(t)=beta*Err(t)+(1-beta)*S(t-1))\t (smoothed error)\n&quot;
printf &quot;  A(t)=beta*abs(Err(t))+(1-beta)*A(t-1)) (absolute smoothed error)\n&quot;
printf &quot;  Err(t)=y(t)-f(t)\t\t\t (forecast error)\n&quot;
printf &quot;-----------------------------------------------------\n&quot;
printf &quot;The parameter is based on min. MSE \n&quot;
printf &quot;Beta: %.3f\n&quot;,beta     # ----&gt;&gt;&gt; stat[1]
printf &quot;Original series: %s\n&quot;, argname(y)
printf &quot;Forecast series: %s\n&quot;, &quot;@yf&quot;
printf &quot;-----------------------------------------------------\n&quot;
sprintf sInfo &quot;ADRES(%s,beta=%.3f)&quot;,argname(y),beta    #--舊的--&gt; mSSE[iCmin[2],1]
# --- 產生最佳預測值
# ---------- series @yf=movavg(y(-1),mSSE[iCmin[2],1])
#printf &quot;----&gt; BOB=%d; EOB=%d\n&quot;,BOB,EOB
# --- 樣本內預測起始、結束位置:
set messages on
smpl full
smpl sdum --dummy
set messages off
BOB=$t1
EOB=$t2
EOS=$t2 # 實際有資料的最後一筆
printf &quot;$t1=%d, $t2=%d ^^^^^^^^^^^^^^^^^^^^^\n&quot;, $t1,$t2
printf &quot;BOB=%d, EOB=%d, predh=%d ^^^after sdum ^^^^^^^^^^^^^^^^^^\n&quot;, BOB,EOB,predh
smpl full
printf &quot;   ++++++++++++++++++++++++++++++++++++++++++\n&quot;
printf &quot;          In-sample forecasting Errors\n&quot;
printf &quot;   ++++++++++++++++++++++++++++++++++++++++++\n&quot;
printf &quot;+++++++++++++ Beta: %.3f\n&quot;,beta     # ----&gt;&gt;&gt; stat[1]
# --- generate first 2 forecasts
genr f[firstobs(y)]=y[firstobs(y)]
genr f[firstobs(y)+1]=y[firstobs(y)+1]
printf &quot;AFTER:$t1=%d, $t2=%d ^^^^^^^^^^^^^^^^^^^^^\n&quot;, $t1,$t2
# print y f Err Serr Aerr --byobs
loop j=BOB+1..EOB --quiet
  genr Err[j]=y[j]-f[j]
  genr Serr[j]=beta*Err[j] + (1-beta)*Serr[j-1]
  genr Aerr[j]=beta*abs(Err[j])+(1-beta)*Aerr[j-1]
  if Aerr[j]==0  #--- 有些資料剛好前幾筆相同, 會有 divided by zero 的狀況, 用很小的非零數隨來排除
    Aerr[j]=0.001*randgen1(z, 0, 1)
  endif
  genr alpha[j] = abs(Serr[j]/Aerr[j])
  if j&lt;=EOB-1
    genr f[j+1]=alpha[j]*y[j] + (1-alpha[j])*f[j]
  endif
endloop
series @yf=f
setinfo @yf -d &quot;@sInfo&quot;
#print mSSE
sprintf tmp &quot;%s&quot;,argname(y)	# name for y
series @tmp=y
BOB=$t1   # ---ADRES 法前兩期是用 naive forecasting, 所以去掉
EOB=$t2
#    print @tmp @yf --byobs
#    print y f Err Serr Aerr --byobs
printf &quot;$t1=%d, $t2=%d $$$$$$$$$$$$$$$$4\n&quot;, $t1,$t2
printf &quot;BOB=%d, EOB=%d $$$$$$$$$$$$$$$$4\n&quot;, BOB,EOB
fcerr(@tmp,@yf,BOB,EOB,1,1)
printf &quot;BOB=%d, EOB=%d, predh=%d ^^^after sdum ^^^^^^^^^^^^^^^^^^\n&quot;, BOB,EOB,predh
printf &quot;===========+++==========================================\n&quot;
if predh&gt;0 # -- 要進行真正的預測
  # --- generate first 2 forecasts
  genr f[firstobs(y)]=y[firstobs(y)]
  genr f[firstobs(y)+1]=y[firstobs(y)+1]
  set messages on
  smpl full
  printf &quot;BOB=%d, EOB=%d,EOS=%d predh=%d, nOSample=%d ^^^^^^^^^^^^^^^^^^^^^\n&quot;, BOB,EOB,EOS,predh,nOSample
  #    smpl ; -predh
  set messages off
  loop j=BOB+1..EOB --quiet
    if j&gt;EOS
      genr y[j]=f[j]
    endif
    genr Err[j]=y[j]-f[j]
    genr Serr[j]=beta*Err[j] + (1-beta)*Serr[j-1]
    genr Aerr[j]=beta*abs(Err[j])+(1-beta)*Aerr[j-1]
    if Aerr[j]==0  #--- 有些資料剛好前幾筆相同, 會有 divided by zero 的狀況, 用很小的非零數隨來排除
      Aerr[j]=0.001*randgen1(z, 0, 1)
    endif
    genr alpha[j] = abs(Serr[j]/Aerr[j])
    if j&lt;EOB # 有實際資料
      printf &quot;j=%d,y[j]=%.3f,f[j]=%.3f\n&quot;,j,y[j],f[j]
      genr f[j+1]=alpha[j]*y[j] + (1-alpha[j])*f[j]
    else
      #genr y[j+1]=f[j+1]
      printf &quot;j=%d,y[j]=%.3f,f[j]=%.3f\n&quot;,j,y[j],f[j]
    endif
  endloop
  fcerr(y,@yf,BOB,EOB,1)
  print y @yf Err Serr Aerr --byobs
  if nOSample&gt;0 # --- 有保留的「樣本外預測」
    printf &quot;   ++++++++++++++++++++++++++++++++++++++++++++++\n&quot;
    printf &quot;        Out-of-sample forecasting Errors\n&quot;
    printf &quot;   ++++++++++++++++++++++++++++++++++++++++++++++\n&quot;
    #printf &quot;&gt;&gt;&gt;&gt;***sm&gt;&gt;&gt;&gt;&gt;&gt;&gt; EOS=%d; nOSample=%d; EOS=%d; \n&quot;,EOS,nOSample,EOS
    #print y_ @yf --byobs
    fcerr(y_,@yf,EOS-nOSample+1,EOS,1)
    printf &quot;====================================================\n\n&quot;
  endif
else # 沒有要進行樣本外預測
  # --- 樣本內預測起始、結束位置:
  # --- generate first 2 forecasts
  genr f[firstobs(y)]=y[firstobs(y)]
  genr f[firstobs(y)+1]=y[firstobs(y)+1]
  #        printf &quot;AFTER:$t1=%d, $t2=%d ^^^^^^^^^^^^^^^^^^^^^\n&quot;, $t1,$t2
  loop j=BOB..EOB --quiet
    genr Err[j]=y[j]-f[j]
    genr Serr[j]=beta*Err[j] + (1-beta)*Serr[j-1]
    genr Aerr[j]=beta*abs(Err[j])+(1-beta)*Aerr[j-1]
    if Aerr[j]==0  #--- 有些資料剛好前幾筆相同, 會有 divided by zero 的狀況, 用很小的非零數隨來排除
      Aerr[j]=0.001*randgen1(z, 0, 1)
    endif
    genr alpha[j] = abs(Serr[j]/Aerr[j])
    if j&lt;=EOB-1
      genr f[j+1]=alpha[j]*y[j] + (1-alpha[j])*f[j]
    endif
  endloop
  set messages on
  smpl full
  smpl sdum --dummy
  set messages off
  BOB=$t1
  EOB=$t2
  printf &quot;$t1=%d, $t2=%d ^^^^^^^^^^^^^^^^^^^^^\n&quot;, $t1,$t2
  printf &quot;BOB=%d, EOB=%d, predh=%d ^^^^^^^^^^^^^^^^^^^^^\n&quot;, BOB,EOB,predh
  smpl full
  printf &quot;   ++++++++++++++++++++++++++++++++++++++++++\n&quot;
  printf &quot;          In-sample forecasting Errors\n&quot;
  printf &quot;   ++++++++++++++++++++++++++++++++++++++++++\n&quot;
  printf &quot;+++++++++++++ Beta: %.3f\n&quot;,beta     # ----&gt;&gt;&gt; stat[1]
  fcerr(@tmp,@yf,BOB,EOB,1,1)
endif
series @yf = f
setinfo @yf -d &quot;@sInfo&quot;
printf &quot;=====================================================\n&quot;
list retlist= @yf
# -測試用--&gt;  print y @yf Err Serr Aerr alpha --byobs
return retlist
</code>
</gretl-function>
<gretl-function name="autoOLS" type="list">
 <params count="10">
  <param name="y_" type="series">
<description>Dependent variable</description>
  </param>
  <param name="nTrend" type="int" min="0" max="3" default="0">
<description>include a trend</description>
<labels count="4">
"none" "linear" "quadratic" "cubic" </labels>
  </param>
  <param name="nSeason" type="int" min="0" max="1" default="1">
<description>include seasonal dummies</description>
<labels count="2">
"none" "Auto" </labels>
  </param>
  <param name="nLag" type="int" min="0" max="1" default="1">
<description>Lags of dependent variable</description>
<labels count="2">
"none" "Auto" </labels>
  </param>
  <param name="reglist" type="list" optional="true">
<description>Exogenous regressors</description>
  </param>
  <param name="nOmit" type="int" min="0" max="2" default="1">
<description>Sequential elimination using two-sided alpha = %.2f</description>
<labels count="3">
"No" "=5%" "=10%" </labels>
  </param>
  <param name="save_yf" type="bool" default="1">
<description>Use default name for forecast series?</description>
  </param>
  <param name="yfname" type="string" optional="true">
<description>Name of forecasts</description>
  </param>
  <param name="nOSample" type="int" min="0" max="5000" default="0">
<description>Number of Out-of-Sample reserved</description>
  </param>
  <param name="nVerbose" type="int" min="0" max="2" default="1">
<description>Show details</description>
<labels count="3">
"No OLS results" "Show only the last OLS" "Show all OLS" </labels>
  </param>
 </params>
<code>set echo off
set messages off
series y=y_
#print y y_ --byobs
sprintf tmp &quot;%s&quot;,argname(y_)	# name for y
sQuiet=&quot; &quot;
sQuietfinal=&quot; &quot;
if nVerbose ==0
  sQuiet=&quot; -q&quot;
  sQuietfinal=&quot; --silent&quot;
endif
if nVerbose ==1
  sQuiet=&quot; -q&quot;
endif
# --- 產生趨勢變數集
list tlist = null
if nTrend==1
  list tlist = time
endif
if nTrend==2
  genr time2=time^2
  list tlist = time time2
endif
if nTrend==3
  genr time2=time^2
  genr time3=time^3
  list tlist = time time2 time3
endif
# --- 產生季節虛擬變數集: 此指令自動依 data structure 產生不同的季節虛擬變數
list slist=null
if nSeason==1
  if $pd&gt;1
    genr dummy
    if $pd==12
      list slist = dm*
    else
      if $pd==4
        list slist = dq*
      else
        list slist = dummy_*
      endif
    endif
  endif
endif
# --- 產生落後期變數集: 此指令自動依 data structure 產生不同的落後期變數
# --- nOSample = 保留為樣本外預測樣本數
smpl ; -nOSample
series y0=y_
list laglist=null
if nLag==1
  lags y0
  list laglist = y0_*
  #list laglist -= y_
endif
list xlist = const || tlist || slist || laglist || reglist
ols y0 xlist @sQuiet
if nOmit==1
  omit --auto=0.05  @sQuietfinal
endif
if nOmit==2
  omit --auto=0.10  @sQuietfinal
endif
genr sdum=$sample
smpl sdum --dummy
BOB=$t1
EOB=$t2
#smpl full
#print y_ y0 --byobs
#printf &quot;************* BOB=%d; EOB=%d; T=%d\n&quot;,BOB,EOB,$T
#set messages on
#smpl $t1 lastobs(y)
smpl full
#print y_ y0 --byobs
#  if nOSample &gt; 0
fcast yf0 #--out-of-sample
#  endif
#myTmp=$yhat
#print y_ yf0 myTmp --byobs
#  smpl ; -nOSample
#  series yf0=$yhat
smpl full
#print y_ yf0 --byobs
if !exists(yfname)
  smpl full
  scalar predh = $t2-lastobs(y0)
  #printf &quot;************* t2=%d; lastobs(y)=%d; predh=%d\n&quot;,$t2,lastobs(y0),predh
  if predh&gt;0
    sprintf yf &quot;%s_ols_out&quot;,argname(y_)	# default name for out-of-sample yf
    sprintf sInfo &quot;%s's forecasts by OLS; The last-%d observations are out-of-sample forecasts &quot;,argname(y_),predh
  else
    sprintf yf &quot;%s_ols&quot;,argname(y_)	    # default name for yf
    sprintf sInfo &quot;%s's forecasts by OLS&quot;,argname(y_)
  endif
else
  smpl full
  scalar predh = $t2-lastobs(y0)
  if predh&gt;0
    # ----- sprintf yf &quot;%s_ols_out&quot;,argname(y_)	# default name for out-of-sample yf
    sprintf yf &quot;%s&quot;,yfname	# user defined name for yf
    sprintf sInfo &quot;%s's forecasts by OLS; The last-%d observations are out-of-sample forecasts &quot;,argname(y_),predh
  else
    #sprintf yf &quot;%s_ols&quot;,argname(y_)	    # default name for yf
    sprintf yf &quot;%s&quot;,yfname	# user defined name for yf
    sprintf sInfo &quot;%s's forecasts by OLS&quot;,argname(y_)
  endif
endif
# --- 將OLS預測結果放到 @yf
series @yf = yf0
#print y_ @yf --byobs
printf &quot;====================================================\n&quot;
set messages on
smpl # +lag -nOSample
set messages off
printf &quot;Forecasts by OLS \n&quot;
printf &quot;----------------------------------------------------\n&quot;
printf &quot;Original series: %s\n&quot;, argname(y_)
printf &quot;Forecast series: %s\n&quot;, &quot;@yf&quot;
printf &quot;----------------------------------------------------\n&quot;
# --- 樣本內預測起始、結束位置:
#BOB=firstobs(y_)
#EOB=lastobs(y_)-predh
smpl sdum --dummy
BOB=$t1
EOB=$t2
smpl full
printf &quot;   ++++++++++++++++++++++++++++++++++++++++++\n&quot;
printf &quot;          In-sample forecasting Errors\n&quot;
printf &quot;   ++++++++++++++++++++++++++++++++++++++++++\n&quot;
#print y_ @yf --byobs
printf &quot;BOB=%d; EOB=%d; predh=%d; ncoeff=%d; firstobs=%d\n&quot;,BOB,EOB,predh,$ncoeff,firstobs(y_)
if firstobs(y_)==BOB  # --- OLS 顯著的係數只剩 const 時, 會採用全樣本, 無法和 naive model 比較而出錯
  BOB=BOB+1
endif
fcerr(y_,@yf,BOB,EOB,1)
if predh&gt;0
  # --- Begin/End of Out-of-Sample
  #BOS=lastobs(y_)-predh+1
  EOS1=lastobs(y_)
  BOS=lastobs(@yf)-predh+1
  EOS=lastobs(@yf)
  if EOS==EOS1
    printf &quot;   ++++++++++++++++++++++++++++++++++++++++++++++\n&quot;
    printf &quot;        Out-of-sample forecasting Errors\n&quot;
    printf &quot;   ++++++++++++++++++++++++++++++++++++++++++++++\n&quot;
    printf &quot;BOS=%d; EOS=%d\n&quot;,BOS,EOS
    #print y_ @yf --byobs
    fcerr(y_,@yf,BOS,EOS,1)
  endif
endif
printf &quot;====================================================\n\n&quot;
setinfo @yf -d &quot;@sInfo&quot;
list retlist= @yf
return retlist
</code>
</gretl-function>
<gretl-function name="genrSI" type="matrix">
 <params count="3">
  <param name="y" type="series">
<description>Variable name</description>
  </param>
  <param name="nYr" type="int" min="0" default="4">
<description>number of initial sample years to generate index</description>
  </param>
  <param name="nMethod" type="int" min="1" max="2" default="1">
<description>Method</description>
<labels count="2">
"simple average" "centered MA" </labels>
  </param>
 </params>
<code># ---This script is to generate Seasonality Indices by selected initial years
# --- calculate initial estimates for SI (seasonality indices)
# -----series   y=Trucks
# --- the selected number of years to be used
# ----nYr=4
# $pd = 4   #--- quarterly data
sEOB = $pd
if nYr==0   # --- indicating full sample
  nYr=int(lastobs(y)/$pd)
endif
matrix mData=zeros(nYr,$pd)
i=1
loop year=1..nYr -q
  loop j=1..sEOB -q
    mData[year,j]=y[i]
    i+=1
  endloop
endloop
AnnAvg=sum(mData)/(nYr*$pd)
MeanC=meanc(mData)
matrix mSI=MeanC/AnnAvg
return mSI
</code>
</gretl-function>
<gretl-function name="fcerr" type="matrix">
 <params count="9">
  <param name="y" type="series">
<description>Variable name</description>
  </param>
  <param name="f" type="series">
<description>forecasted variable to be compared</description>
  </param>
  <param name="strobs" type="int" default="10">
<description>starting from:</description>
  </param>
  <param name="endobs" type="int" default="100">
<description>to:</description>
  </param>
  <param name="showRMSE" type="bool" default="1">
<description>show RMSE</description>
  </param>
  <param name="showMSE" type="bool" default="0">
<description>show MSE</description>
  </param>
  <param name="showMAE" type="bool" default="1">
<description>show MAE</description>
  </param>
  <param name="showMAPE" type="bool" default="1">
<description>show MAPE</description>
  </param>
  <param name="showTheilU" type="bool" default="0">
<description>show Theil's U</description>
  </param>
 </params>
<code>#set echo off
#set messages off
smpl strobs endobs
showRMSE=1
matrix mx=fcstats(y,f)
#print mx
matrix ret_mx =mx[2]|mx[3]|mx[5]|mx[6]
#    print mx
#    print ret_mx
#自動和 Naive model 比較
series f=movavg(y(-1),1)
#smpl -1 ;
matrix mx=fcstats(y,f)
MSE=mx[2]
MAE=mx[3]
MAPE=mx[5]
TheilU=mx[6]
matrix tmp =mx[2]|mx[3]|mx[5]|mx[6]
matrix stats=tmp ~ ret_mx
set messages on
smpl
set messages off
printf &quot;\n           %16s %16s \n&quot;,&quot;Naive&quot;, argname(f)
if showRMSE
  printf &quot;RMSE       %16.4f %16.4f \n&quot;,stats[1,1],stats[1,2]
endif
if showMSE
  if stats[1,1]&gt;0.001
    printf &quot;MSE        %16.4f %16.4f \n&quot;,stats[1,1]^2,stats[1,2]^2
  else
    printf &quot;MSE        %16.4g %16.4g \n&quot;,stats[1,1]^2,stats[1,2]^2
  endif
endif
if showMAE
  printf   &quot;MAE        %16.4f %16.4f \n&quot;,stats[2,1],stats[2,2]
endif
if showMAPE
  printf   &quot;MAPE       %16.4f %16.4f \n&quot;,stats[3,1],stats[3,2]
endif
if showTheilU
  printf   &quot;Theil's U  %16.4f %16.4f \n&quot;,stats[4,1],stats[4,2]
endif
return ret_mx
</code>
</gretl-function>
<gretl-function name="HW2" type="list">
 <params count="5">
  <param name="y" type="series">
<description>Dependent variable</description>
  </param>
  <param name="delta1" type="scalar" min="0" max="1" default="0.3">
<description>Level smoothness parameter</description>
  </param>
  <param name="delta2" type="scalar" min="0" max="1" default="0.1">
<description>Slope smoothness parameter</description>
  </param>
  <param name="delta3" type="scalar" min="0" max="1" default="0.7">
<description>Seasonality smoothness parameter</description>
  </param>
  <param name="printresults" type="bool" default="0">
<description>Print numerical results</description>
  </param>
 </params>
<code>catch smpl y --contiguous
if $error
  print &quot;There are internal missing values&quot;
endif
string sy = argname(y)
genr time
#Holt
#Initial values by means of a global linear trend
ols y 0 time --quiet
series yh1=$yhat
series s1 = NA*const
series b1 = NA*const
scalar f=firstobs(y)
scalar f2=firstobs(y)+1
genr s1[f]=yh1[f]
genr b1[f]=yh1[f2]-yh1[f]
scalar lobs=lastobs(y)-firstobs(y)+1 # Current sample size
loop i=f2..lobs --quiet
  genr s1[i] = delta1*y[i] + (1-delta1)*(s1[i-1]+b1[i-1])
  genr b1[i] = delta2*(s1[i]-s1[i-1]) + (1-delta2)*b1[i-1]
endloop
smpl --full
# Number of predictions, equal to the number of missing obs. at the end of the variable
scalar predh = $t2-lastobs(y)
if predh&gt;0
  loop i=1..predh --quiet
    scalar ji=lobs+i
    genr s1[ji] = s1[ji-1]+b1[ji-1]
    genr b1[ji] = b1[ji-1]
  endloop
endif
series @sy_H = s1(-1)+b1(-1)
setinfo @sy_H -d &quot;Holt's trend prediction component&quot; -n &quot;Holt smoother&quot;
list salida = @sy_H
#Winters
if $pd&gt;1
  series s1 = y
  series b1 = NA*const
  series I1 = NA*const
  #Computing initial values for the seasonal based on 4 years data
  scalar s=$pd
  scalar s4=firstobs(y)+4*s-1
  series dumvar = (obs&lt;=s4 &amp;&amp; obs&gt;=f)
  if lobs&lt;s4
    print &quot;Insuficient data (4 years needed)&quot;
  endif
  smpl dumvar --dummy
  ols y 0 time --quiet
  series yh=y/$yhat
  scalar b11=0
  scalar denom=0
  scalar fs=firstobs(y)+(s-1)
  loop i=f..fs --quiet
    scalar j1 = i+s
    scalar j2 = i+2*s
    scalar j3 = i+3*s
    genr I1[i]=(yh[i]+yh[j1]+yh[j2]+yh[j3])/4
    scalar b11 = b11 + y[s+i]-y[i]
    scalar denom = denom + I1[i]
  endloop
  #scalar cf=s/(I1[1]+I1[2]+I1[3]+I1[4])
  scalar cf = s/denom
  series I1 = cf*I1
  genr b1[fs]=b11/(s^2)
  genr s1[fs]=y[fs]
  #Evaluating the components for the rest of the sample
  scalar sm1=firstobs(y)+s
  loop i=sm1..lobs --quiet
    genr s1[i] = delta1*(y[i]/I1[i-s]) + (1-delta1)*(s1[i-1]+b1[i-1])
    genr b1[i] = delta2*(s1[i]-s1[i-1]) + (1-delta2)*b1[i-1]
    genr I1[i] = delta3*(y[i]/s1[i])+(1-delta3)*I1[i-s]
  endloop
  smpl --full
  scalar predh = $t2-lastobs(y)
  if predh&gt;0
    loop i=1..predh --quiet
      scalar ji=lobs+i
      genr s1[ji] = s1[ji-1]+b1[ji-1]
      genr b1[ji] = b1[ji-1]
      genr I1[ji] = I1[ji-s]
    endloop
  endif
  series @sy_W = (s1(-1)+b1(-1))*I1(-s)
  series @sy_SF = I1  # ---- SF: seasonal factors
  setinfo @sy_W -d &quot;Winters' trend + seasonal prediction component&quot; -n &quot;Winters smoother&quot;
  list salida += @sy_W @sy_SF
endif
if $pd==1
  #printf &quot;\n Annual data. There is no seasonality, so the Winters component is not computed\n&quot;
endif
if printresults==1
  print salida --byobs
endif
return salida
</code>
</gretl-function>
<sample-script>
include fcModels.gfn
open djclose
L = autoMA(djclose, 10, 1, null, 30)
L = autoOLS(djclose, 3, 1, 1, null, 1, 1, null, 30, 1)
smpl 1989-08-01 ;
gnuplot djclose djclose_ma1_out --with-lines --time-series --output=display
gnuplot djclose djclose_ols_out --with-lines --time-series --output=display
</sample-script>
</gretl-function-package>
</gretl-functions>
